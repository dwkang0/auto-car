struct edge_data{
    int car_n;
    int to;
    double len;
    edge_data(int car_n=0, int to=0, double len=0.0){
        this->car_n = car_n;
        this->to = to;
        this->len = len;
    }
    bool operator < (const edge_data &b) const{
        return (this->len)>(b.len);
    }
};

void ClearQueue(priority_queue<edge_data> &someQueue){
    priority_queue<edge_data> empty;
    swap(someQueue, empty);
}
void ClearQueue2(priority_queue<edge> &someQueue){
    priority_queue<edge> empty;
    swap(someQueue, empty);
}
void dijkstra_first(input * data){
    int (* v_xy)[2]=(int (*)[2])data->data_v;
    int (* car_road)[2]=(int (*)[2])data->data_c;
    int V=data->V;  int C=data->C;
    float * speed=data->c_speed;
    edge_data road_t;
    int u;

    struct state{
        int carv;
        int cart;
        double * roadtotal;
        int * check;
        int * link;
        int linking;
        double car_roadtotal;
        int * data_link;
        int * car_link;
        int car_check;
        double t_l;
    }g_s[C];
    priority_queue<edge_data> road_t_q;

    double roadtotal[V];     int check[V];
    priority_queue<edge> road_t_q2;      edge road_t2;
    for(int car_n=0;car_n<C;car_n++){
        for(int i=0;i<V;i++){
            roadtotal[i]=INF;
            check[i]=0;
        }
        roadtotal[car_road[car_n][0]]=0;
        road_t_q2.push(edge(car_road[car_n][0], 0));
        int u;
        while(!road_t_q2.empty()){
            road_t2=road_t_q2.top(); road_t_q2.pop();
            u=road_t2.to;
            if(u==car_road[car_n][1]){
                break;
            }
            if(check[u]==0){
                for(int i=0; i<data->g[u].size(); i++){
                    int v=data->g[u][i].to; double h;
                    if(check[v]==0){
                        if(roadtotal[u]<roadtotal[v]-data->g[u][i].len){
                            roadtotal[v]=roadtotal[u]+data->g[u][i].len;
                            h=sqrt(pow((v_xy[v][0]-v_xy[car_road[car_n][1]][0]), 2)+pow((v_xy[v][1]-v_xy[car_road[car_n][1]][1]), 2));
                            road_t_q2.push(edge(v, roadtotal[v]+h));
                        }
                    }
                }
                check[u]=1;
            }
        }
        ClearQueue2(road_t_q2);

        g_s[car_n].t_l=roadtotal[car_road[car_n][1]];
        printf("%d : %f\n", car_n+1, roadtotal[car_road[car_n][1]]);
    }


    for(int car_n=0;car_n<C;car_n++){
        g_s[car_n].roadtotal=(double *)malloc(8*V);
        g_s[car_n].check=(int *)malloc(4*V);
        g_s[car_n].link=(int *)malloc(4*V);
        g_s[car_n].data_link=(int *)malloc(4*V);
        for(int i=0;i<V;i++){
            g_s[car_n].roadtotal[i]=INF;
            g_s[car_n].check[i]=0;
            g_s[car_n].link[i]=-1;
        }
        g_s[car_n].roadtotal[car_road[car_n][0]]=0;
        road_t_q.push(edge_data(car_n, car_road[car_n][0], 0));
        g_s[car_n].link[car_road[car_n][0]]=car_road[car_n][0];
        g_s[car_n].car_check=0;
    }

    while(!road_t_q.empty()){
        road_t=road_t_q.top(); road_t_q.pop();
        int car_n=road_t.car_n;
        if(g_s[car_n].car_check==0){
            u=road_t.to;
            if(u==car_road[car_n][1]){
                g_s[car_n].car_check=1;
            }
            printf("차 %d : 정점%d : 시간비%f 시간%f\n", car_n+1, u, road_t.len, g_s[car_n].roadtotal[u]);
            if(g_s[car_n].check[u]==0){
                for(int i=0; i<(int)data->g[u].size(); i++){
                    int v=data->g[u][i].to; double h;
                    if(g_s[car_n].check[v]==0){
                        if(g_s[car_n].roadtotal[u]<g_s[car_n].roadtotal[v]-(data->g[u][i].len/speed[car_n])){
                            g_s[car_n].roadtotal[v]=g_s[car_n].roadtotal[u]+(data->g[u][i].len/speed[car_n]);
                            h=sqrt(pow((v_xy[v][0]-v_xy[car_road[car_n][1]][0]), 2)+pow((v_xy[v][1]-v_xy[car_road[car_n][1]][1]), 2));
                            road_t_q.push(edge_data(car_n, v, ((g_s[car_n].roadtotal[v]+h/speed[car_n])*speed[car_n]/(g_s[car_n].t_l))));
                            g_s[car_n].link[v]=u;
                        }
                    }
                }
                g_s[car_n].check[u]=1;
            }
        }
    }
    ClearQueue(road_t_q);

    for(int car_n=0;car_n<C;car_n++){
        g_s[car_n].car_roadtotal=g_s[car_n].roadtotal[car_road[car_n][1]];
        for(int i=0;i<V;i++){
            g_s[car_n].data_link[i]=-1;
        }
        g_s[car_n].data_link[0]=car_road[car_n][1];
        g_s[car_n].linking=V;
        for(int i=1;i<V;i++){
            g_s[car_n].data_link[i]=g_s[car_n].link[g_s[car_n].data_link[i-1]];
            if(g_s[car_n].data_link[i]==car_road[car_n][0]){
                g_s[car_n].linking=i+1;
                break;
            }
        }
        g_s[car_n].car_link=(int *)malloc(4*g_s[car_n].linking);
        for(int i=0;i<g_s[car_n].linking;i++){
            g_s[car_n].car_link[g_s[car_n].linking-i-1]=g_s[car_n].data_link[i];
        }
        printf("차%d의 시간:%.3f\n차%d의 이동경로:", (car_n+1), g_s[car_n].car_roadtotal, (car_n+1));
        for(int i=0;i<g_s[car_n].linking;i++){
            printf("%d ", g_s[car_n].car_link[i]);
        }
        printf("\n");
    }
}

